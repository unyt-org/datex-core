use crate::ast::resolved_variable::{ResolvedVariable, VariableId};
use crate::ast::spanned::Spanned;
use crate::ast::type_expressions::TypeExpression;
use crate::global::operators::BinaryOperator;
use crate::global::operators::ComparisonOperator;
use crate::global::operators::assignment::AssignmentOperator;
use crate::global::operators::{ArithmeticUnaryOperator, UnaryOperator};
use crate::references::reference::ReferenceMutability;
use crate::stdlib::vec::Vec;
use crate::values::core_value::CoreValue;
use crate::values::core_values::decimal::Decimal;
use crate::values::core_values::decimal::typed_decimal::TypedDecimal;
use crate::values::core_values::endpoint::Endpoint;
use crate::values::core_values::integer::Integer;
use crate::values::core_values::integer::typed_integer::TypedInteger;
use crate::values::core_values::r#type::Type;
use crate::values::pointer::PointerAddress;
use crate::values::value::Value;
use crate::values::value_container::ValueContainer;
use core::fmt::Display;
use core::ops::{Neg, Range};

#[derive(Clone, Debug)]
/// An expression in the AST
pub struct DatexExpression {
    pub data: DatexExpressionData,
    pub span: Range<usize>,
    pub wrapped: Option<usize>, // number of wrapping parentheses
    pub ty: Option<Type>,
}
impl Default for DatexExpression {
    fn default() -> Self {
        DatexExpression {
            data: DatexExpressionData::Statements(Statements {
                statements: Vec::new(),
                is_terminated: false,
                unbounded: None,
            }),
            span: 0..0,
            wrapped: None,
            ty: None,
        }
    }
}
impl DatexExpression {
    pub fn new(data: DatexExpressionData, span: Range<usize>) -> Self {
        DatexExpression {
            data,
            span,
            wrapped: None,
            ty: None,
        }
    }
}

// PartialEquality for DatexExpression ignores the span (allows for easier testing)
impl PartialEq for DatexExpression {
    fn eq(&self, other: &Self) -> bool {
        self.data == other.data
    }
}

#[derive(Clone, Debug, PartialEq)]
/// The different kinds of type expressions in the AST
#[derive(Default)]
pub enum DatexExpressionData {
    /// This is a marker for recovery from parse errors.
    /// We should never use this manually.
    #[default]
    Noop,

    Recover,

    /// null
    Null,
    /// Boolean (true or false)
    Boolean(bool),
    /// Text, e.g "Hello, world!"
    Text(String),
    /// Decimal, e.g 123.456789123456
    Decimal(Decimal),

    /// Typed Decimal, e.g. 123.456i8
    TypedDecimal(TypedDecimal),

    /// Integer, e.g 123456789123456789
    Integer(Integer),

    /// Typed Integer, e.g. 123i8
    TypedInteger(TypedInteger),

    /// Identifier (variable / core type usage)
    Identifier(String),

    /// Endpoint, e.g. @test_a or @test_b
    Endpoint(Endpoint),
    /// List, e.g  `[1, 2, 3, "text"]`
    List(List),
    /// Map, e.g {"xy": 2, (3): 4, xy: "xy"}
    Map(Map),
    /// One or more statements, e.g (1; 2; 3)
    Statements(Statements),
    /// reference access, e.g. &<ABCDEF>
    GetReference(PointerAddress),

    /// Conditional expression, e.g. if (true) { 1 } else { 2 }
    Conditional(Conditional),

    // TODO: Give information on type kind (nominal & structural)
    /// Variable declaration, e.g. const x = 1, const mut x = 1, or var y = 2. VariableId is always set to 0 by the ast parser.
    VariableDeclaration(VariableDeclaration),
    /// Variable assignment, e.g. x = 42 or y += 1
    VariableAssignment(VariableAssignment),
    /// Variable access - only generated by the precompiler, not by the parser
    VariableAccess(VariableAccess),

    // TODO: Shall we avoid hoisting for type aliases?
    // This would remove the ability to have recursive type
    // definitions.
    /// Type declaration, e.g. type MyType = { x: 42, y: "John" };
    TypeDeclaration(TypeDeclaration),

    /// Type expression, e.g. type(1 | 2)
    TypeExpression(TypeExpression),

    /// callable (function/procedure) declaration, e.g. function my_function() -> type ( ... )
    CallableDeclaration(CallableDeclaration),

    // TODO combine
    /// Reference, e.g. &x or &mut x
    CreateRef(CreateRef),

    /// Deref
    Deref(Deref),

    /// Slot, e.g. #1, #endpoint
    Slot(Slot),

    /// Slot assignment
    SlotAssignment(SlotAssignment),

    /// Pointer address $<identifier>
    PointerAddress(PointerAddress),

    /// Binary operation, e.g. x + y
    BinaryOperation(BinaryOperation),

    /// Comparison operation, e.g. x < y
    ComparisonOperation(ComparisonOperation),

    /// Deref assignment, e.g. *x = y, **x += y
    DerefAssignment(DerefAssignment),

    /// Property assignment, e.g. obj.property = value
    PropertyAssignment(PropertyAssignment),

    /// Unary operation, e.g. -x, !x
    UnaryOperation(UnaryOperation),

    /// Apply a value to another value, e.g. function call or type cast
    Apply(Apply),

    /// Apply a property access to an argument
    PropertyAccess(PropertyAccess),

    /// Generic instantiation, e.g. MyType<u8>
    GenericInstantiation(GenericInstantiation),

    /// The '?' placeholder expression
    Placeholder,

    /// Remote execution, e.g. @example :: 41 + 1
    RemoteExecution(RemoteExecution),

    /// Variant access, e.g. integer/u8
    VariantAccess(VariantAccess),
}

impl Spanned for DatexExpressionData {
    type Output = DatexExpression;

    fn with_span<T: Into<Range<usize>>>(self, span: T) -> Self::Output {
        DatexExpression {
            data: self,
            span: span.into(),
            wrapped: None,
            ty: None,
        }
    }

    fn with_default_span(self) -> Self::Output {
        DatexExpression {
            data: self,
            span: (0..0),
            wrapped: None,
            ty: None,
        }
    }
}

// directly convert DatexExpression to a ValueContainer
impl TryFrom<&DatexExpressionData> for ValueContainer {
    type Error = ();

    fn try_from(expr: &DatexExpressionData) -> Result<Self, Self::Error> {
        Ok(match expr {
            DatexExpressionData::UnaryOperation(UnaryOperation {
                operator,
                expression,
            }) => {
                let value = ValueContainer::try_from(&expression.data)?;
                match value {
                    ValueContainer::Value(Value {
                        inner: CoreValue::Integer(_) | CoreValue::Decimal(_),
                        ..
                    }) => match operator {
                        UnaryOperator::Arithmetic(
                            ArithmeticUnaryOperator::Plus,
                        ) => value,
                        UnaryOperator::Arithmetic(
                            ArithmeticUnaryOperator::Minus,
                        ) => value.neg().map_err(|_| ())?,
                        _ => Err(())?,
                    },
                    _ => Err(())?,
                }
            }
            DatexExpressionData::Null => ValueContainer::Value(Value::null()),
            DatexExpressionData::Boolean(b) => ValueContainer::from(*b),
            DatexExpressionData::Text(s) => ValueContainer::from(s.clone()),
            DatexExpressionData::Decimal(d) => ValueContainer::from(d.clone()),
            DatexExpressionData::Integer(i) => ValueContainer::from(i.clone()),
            DatexExpressionData::TypedInteger(i) => {
                ValueContainer::from(i.clone())
            }
            DatexExpressionData::TypedDecimal(d) => {
                ValueContainer::from(d.clone())
            }
            DatexExpressionData::Endpoint(e) => ValueContainer::from(e.clone()),
            DatexExpressionData::List(list) => {
                let entries = list
                    .items
                    .iter()
                    .map(|e| ValueContainer::try_from(&e.data))
                    .collect::<Result<Vec<ValueContainer>, ()>>()?;
                ValueContainer::from(
                    datex_core::values::core_values::list::List::from(entries),
                )
            }
            DatexExpressionData::Map(pairs) => {
                let entries = pairs
                    .entries
                    .iter()
                    .map(|(k, v)| {
                        let key = ValueContainer::try_from(&k.data)?;
                        let value = ValueContainer::try_from(&v.data)?;
                        Ok((key, value))
                    })
                    .collect::<Result<Vec<(ValueContainer, ValueContainer)>, ()>>()?;
                ValueContainer::from(
                    crate::values::core_values::map::Map::from(entries),
                )
            }
            _ => Err(())?,
        })
    }
}

#[derive(Clone, Debug, PartialEq)]
pub struct BinaryOperation {
    pub operator: BinaryOperator,
    pub left: Box<DatexExpression>,
    pub right: Box<DatexExpression>,
    pub ty: Option<Type>,
}

#[derive(Clone, Debug, PartialEq)]
pub struct ComparisonOperation {
    pub operator: ComparisonOperator,
    pub left: Box<DatexExpression>,
    pub right: Box<DatexExpression>,
}

#[derive(Clone, Debug, PartialEq)]
pub struct DerefAssignment {
    pub operator: AssignmentOperator,
    pub deref_expression: Box<DatexExpression>,
    pub assigned_expression: Box<DatexExpression>,
}

#[derive(Clone, Debug, PartialEq)]
pub struct PropertyAssignment {
    pub operator: AssignmentOperator,
    pub access_expression: Box<DatexExpression>,
    pub assigned_property: Box<DatexExpression>,
    pub assigned_expression: Box<DatexExpression>,
}

#[derive(Clone, Debug, PartialEq)]
pub struct Conditional {
    pub condition: Box<DatexExpression>,
    pub then_branch: Box<DatexExpression>,
    pub else_branch: Option<Box<DatexExpression>>,
}

#[derive(Clone, Debug, PartialEq)]
pub enum TypeDeclarationKind {
    Nominal,
    Structural,
}
impl Display for TypeDeclarationKind {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        match self {
            TypeDeclarationKind::Nominal => core::write!(f, "type"),
            TypeDeclarationKind::Structural => core::write!(f, "typealias"),
        }
    }
}
impl TypeDeclarationKind {
    pub fn is_nominal(&self) -> bool {
        matches!(self, TypeDeclarationKind::Nominal)
    }
    pub fn is_structural(&self) -> bool {
        matches!(self, TypeDeclarationKind::Structural)
    }
}

#[derive(Clone, Debug, PartialEq)]
pub struct TypeDeclaration {
    pub id: Option<VariableId>,
    pub name: String, // TODO: separate variant from name
    pub definition: TypeExpression,
    pub hoisted: bool,
    pub kind: TypeDeclarationKind,
}

#[derive(Clone, Debug, PartialEq)]
pub struct UnaryOperation {
    pub operator: UnaryOperator,
    pub expression: Box<DatexExpression>,
}

#[derive(Clone, Debug, PartialEq)]
pub struct Apply {
    pub base: Box<DatexExpression>,
    pub arguments: Vec<DatexExpression>,
}

#[derive(Clone, Debug, PartialEq)]
pub struct PropertyAccess {
    pub base: Box<DatexExpression>,
    pub property: Box<DatexExpression>,
}

#[derive(Clone, Debug, PartialEq)]
pub struct GenericInstantiation {
    pub base: Box<DatexExpression>,
    pub generic_arguments: Vec<TypeExpression>,
}

#[derive(Clone, Debug, PartialEq)]
pub struct RemoteExecution {
    pub left: Box<DatexExpression>,
    pub right: Box<DatexExpression>,
}

#[derive(Clone, Debug, PartialEq)]
pub struct UnboundedStatement {
    pub is_first: bool,
    pub is_last: bool,
}

#[derive(Clone, Debug, PartialEq)]
pub struct Statements {
    pub statements: Vec<DatexExpression>,
    pub is_terminated: bool,
    pub unbounded: Option<UnboundedStatement>,
}
impl Statements {
    pub fn empty() -> Self {
        Statements {
            statements: Vec::new(),
            is_terminated: true,
            unbounded: None,
        }
    }
    pub fn new_terminated(statements: Vec<DatexExpression>) -> Self {
        Statements {
            statements,
            is_terminated: true,
            unbounded: None,
        }
    }
    pub fn new_unterminated(statements: Vec<DatexExpression>) -> Self {
        Statements {
            statements,
            is_terminated: false,
            unbounded: None,
        }
    }
}

#[derive(Clone, Debug, PartialEq)]
pub struct VariableDeclaration {
    pub id: Option<VariableId>,
    pub kind: VariableKind,
    pub name: String,
    pub type_annotation: Option<TypeExpression>,
    pub init_expression: Box<DatexExpression>,
}

#[derive(Clone, Debug, PartialEq)]
pub struct VariableAssignment {
    pub id: Option<VariableId>,
    pub name: String,
    pub operator: AssignmentOperator,
    pub expression: Box<DatexExpression>,
}

#[derive(Clone, Debug, PartialEq)]
pub struct VariableAccess {
    pub id: VariableId,
    pub name: String,
}

#[derive(Clone, Debug, PartialEq)]
pub enum CallableKind {
    Function,
    Procedure,
}

impl Display for CallableKind {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        match self {
            CallableKind::Function => core::write!(f, "function"),
            CallableKind::Procedure => core::write!(f, "procedure"),
        }
    }
}

#[derive(Clone, Debug, PartialEq)]
pub struct CallableDeclaration {
    pub name: String,
    pub kind: CallableKind,
    pub parameters: Vec<(String, TypeExpression)>,
    pub return_type: Option<TypeExpression>,
    pub body: Box<DatexExpression>,
}

#[derive(Clone, Debug, PartialEq)]
pub struct List {
    pub items: Vec<DatexExpression>,
}

impl List {
    pub fn new(items: Vec<DatexExpression>) -> Self {
        List { items }
    }
}

#[derive(Clone, Debug, PartialEq)]
pub struct Map {
    pub entries: Vec<(DatexExpression, DatexExpression)>,
}

impl Map {
    pub fn new(entries: Vec<(DatexExpression, DatexExpression)>) -> Self {
        Map { entries }
    }
}

#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub enum VariableKind {
    Const,
    Var,
}

impl Display for VariableKind {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        match self {
            VariableKind::Const => core::write!(f, "const"),
            VariableKind::Var => core::write!(f, "var"),
        }
    }
}

#[derive(Clone, Debug, PartialEq)]
pub enum Slot {
    Addressed(u32),
    Named(String),
}
impl Display for Slot {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        core::write!(f, "#")?;
        match self {
            Slot::Addressed(addr) => core::write!(f, "{}", addr),
            Slot::Named(name) => core::write!(f, "{}", name),
        }
    }
}

#[derive(Clone, Debug, PartialEq)]
pub struct SlotAssignment {
    pub slot: Slot,
    pub expression: Box<DatexExpression>,
}

#[derive(Clone, Debug, PartialEq)]
pub struct VariantAccess {
    pub name: String,
    pub variant: String,
    pub base: ResolvedVariable,
}

#[derive(Clone, Debug, PartialEq)]
pub struct Deref {
    pub expression: Box<DatexExpression>,
}

#[derive(Clone, Debug, PartialEq)]
pub struct CreateRef {
    pub mutability: ReferenceMutability,
    pub expression: Box<DatexExpression>,
}
