use std::fmt::Display;
use std::ops::Neg;
use chumsky::prelude::SimpleSpan;
use crate::ast::assignment_operation::AssignmentOperator;
use crate::ast::binary_operation::BinaryOperator;
use crate::ast::binding::VariableId;
use crate::ast::chain::ApplyOperation;
use crate::ast::comparison_operation::ComparisonOperator;
use crate::ast::Statement;
use crate::ast::unary_operation::{ArithmeticUnaryOperator, UnaryOperator};
use crate::values::core_value::CoreValue;
use crate::values::core_values::decimal::Decimal;
use crate::values::core_values::decimal::typed_decimal::TypedDecimal;
use crate::values::core_values::endpoint::Endpoint;
use crate::values::core_values::integer::Integer;
use crate::values::core_values::integer::typed_integer::TypedInteger;
use crate::values::core_values::list::List;
use crate::values::core_values::map::Map;
use crate::values::core_values::r#type::Type;
use crate::values::pointer::PointerAddress;
use crate::values::value::Value;
use crate::values::value_container::ValueContainer;

#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub enum VariableKind {
    Const,
    Var,
}

impl Display for VariableKind {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            VariableKind::Const => write!(f, "const"),
            VariableKind::Var => write!(f, "var"),
        }
    }
}

#[derive(Clone, Debug, PartialEq)]
pub enum Slot {
    Addressed(u32),
    Named(String),
}

#[derive(Clone, Debug, PartialEq)]
pub enum TypeExpression {
    Null,
    // a type name or variable, e.g. integer, string, User, MyType, T
    Literal(String),

    Variable(VariableId, String),
    GetReference(PointerAddress),

    // literals
    Integer(Integer),
    TypedInteger(TypedInteger),
    Decimal(Decimal),
    TypedDecimal(TypedDecimal),
    Boolean(bool),
    Text(String),
    Endpoint(Endpoint),

    // [integer, text, endpoint]
    // size known to compile time, arbitrary types
    StructuralList(Vec<TypeExpression>),

    // [text; 3], integer[10]
    // fixed size and known to compile time, only one type
    FixedSizeList(Box<TypeExpression>, usize),

    // text[], integer[]
    // size not known to compile time, only one type
    SliceList(Box<TypeExpression>),

    // text & "test"
    Intersection(Vec<TypeExpression>),

    // text | integer
    Union(Vec<TypeExpression>),

    // User<text, integer>
    Generic(String, Vec<TypeExpression>),

    // (x: text) -> text
    Function {
        parameters: Vec<(String, TypeExpression)>,
        return_type: Box<TypeExpression>,
    },

    // structurally typed map, e.g. { x: integer, y: text }
    StructuralMap(Vec<(TypeExpression, TypeExpression)>),

    // modifiers
    Ref(Box<TypeExpression>),
    RefMut(Box<TypeExpression>),
    RefFinal(Box<TypeExpression>),
}


#[derive(Clone, Debug)]
pub struct DatexExpression {
    pub data: DatexExpressionData,
    pub span: SimpleSpan
}

// PartialEquality for DatexExpression ignores the span (allows for easier testing)
impl PartialEq for DatexExpression {
    fn eq(&self, other: &Self) -> bool {
        self.data == other.data
    }
}


#[derive(Clone, Debug, PartialEq)]
pub enum DatexExpressionData {
    /// This is a marker for recovery from parse errors.
    /// We should never use this manually.
    Recover,

    /// null
    Null,
    /// Boolean (true or false)
    Boolean(bool),
    /// Text, e.g "Hello, world!"
    Text(String),
    /// Decimal, e.g 123.456789123456
    Decimal(Decimal),

    /// Typed Decimal, e.g. 123.456i8
    TypedDecimal(TypedDecimal),

    /// Integer, e.g 123456789123456789
    Integer(Integer),

    /// Typed Integer, e.g. 123i8
    TypedInteger(TypedInteger),

    /// Identifier (variable / core type usage)
    Identifier(String),

    /// Endpoint, e.g. @test_a or @test_b
    Endpoint(Endpoint),
    /// List, e.g  `[1, 2, 3, "text"]`
    List(Vec<DatexExpression>),
    /// Map, e.g {"xy": 2, (3): 4, xy: "xy"}
    Map(Vec<(DatexExpression, DatexExpression)>),
    /// One or more statements, e.g (1; 2; 3)
    Statements(Vec<Statement>),
    /// Variable name - only generated by the precompiler, not by the parser
    Variable(VariableId, String),
    /// reference access, e.g. &<ABCDEF>
    GetReference(PointerAddress),

    /// Conditional expression, e.g. if (true) { 1 } else { 2 }
    Conditional {
        condition: Box<DatexExpression>,
        then_branch: Box<DatexExpression>,
        else_branch: Option<Box<DatexExpression>>,
    },

    // TODO: Give information on type kind (nominal & structural)
    /// Variable declaration, e.g. const x = 1, const mut x = 1, or var y = 2. VariableId is always set to 0 by the ast parser.
    VariableDeclaration {
        id: Option<VariableId>,
        kind: VariableKind,
        name: String,
        type_annotation: Option<TypeExpression>,
        init_expression: Box<DatexExpression>,
    },

    // TODO: Shall we avoid hoisting for type aliases?
    // This would remove the ability to have recursive type
    // definitions.
    /// Type declaration, e.g. type MyType = { x: 42, y: "John" };
    TypeDeclaration {
        id: Option<VariableId>,
        name: String,
        value: TypeExpression, // Type
        hoisted: bool,
    },

    /// Type expression, e.g. { x: 42, y: "John" }
    TypeExpression(TypeExpression),

    /// Type keyword, e.g. type(...)
    Type(TypeExpression),

    FunctionDeclaration {
        name: String,
        parameters: Vec<(String, TypeExpression)>,
        return_type: Option<TypeExpression>,
        body: Box<DatexExpression>,
    },

    // TODO combine
    /// Reference, e.g. &x
    CreateRef(Box<DatexExpression>),
    /// Mutable reference, e.g. &mut x
    CreateRefMut(Box<DatexExpression>),
    /// Final reference, e.g. &final x
    CreateRefFinal(Box<DatexExpression>),

    /// Deref
    Deref(Box<DatexExpression>),

    /// Slot, e.g. #1, #endpoint
    Slot(Slot),
    /// Slot assignment
    SlotAssignment(Slot, Box<DatexExpression>),

    PointerAddress(PointerAddress),

    // TODO struct instead of tuple
    BinaryOperation(
        BinaryOperator,
        Box<DatexExpression>,
        Box<DatexExpression>,
        Option<Type>,
    ),
    ComparisonOperation(
        ComparisonOperator,
        Box<DatexExpression>,
        Box<DatexExpression>,
    ),
    VariableAssignment(
        AssignmentOperator,
        Option<VariableId>,
        String,
        Box<DatexExpression>,
    ),
    DerefAssignment {
        operator: AssignmentOperator,
        deref_count: usize,
        deref_expression: Box<DatexExpression>,
        assigned_expression: Box<DatexExpression>,
    },
    UnaryOperation(UnaryOperator, Box<DatexExpression>),

    // apply (e.g. x (1)) or property access
    ApplyChain(Box<DatexExpression>, Vec<ApplyOperation>),

    // ?
    Placeholder,
    // @xy :: z
    RemoteExecution(Box<DatexExpression>, Box<DatexExpression>),
}

impl DatexExpressionData {
    pub(crate) fn with_span(self, span: SimpleSpan) -> DatexExpression {
        DatexExpression { data: self, span }
    }

    pub(crate) fn with_default_span(self) -> DatexExpression {
        DatexExpression { data: self, span: SimpleSpan::from(0..0) }
    }
}

// directly convert DatexExpression to a ValueContainer
impl TryFrom<&DatexExpressionData> for ValueContainer {
    type Error = ();

    fn try_from(expr: &DatexExpressionData) -> Result<Self, Self::Error> {
        Ok(match expr {
            DatexExpressionData::UnaryOperation(op, expr) => {
                let value = ValueContainer::try_from(&expr.data)?;
                match value {
                    ValueContainer::Value(Value {
                                              inner: CoreValue::Integer(_) | CoreValue::Decimal(_),
                                              ..
                                          }) => match op {
                        UnaryOperator::Arithmetic(
                            ArithmeticUnaryOperator::Plus,
                        ) => value,
                        UnaryOperator::Arithmetic(
                            ArithmeticUnaryOperator::Minus,
                        ) => value.neg().map_err(|_| ())?,
                        _ => Err(())?,
                    },
                    _ => Err(())?,
                }
            }
            DatexExpressionData::Null => ValueContainer::Value(Value::null()),
            DatexExpressionData::Boolean(b) => ValueContainer::from(*b),
            DatexExpressionData::Text(s) => ValueContainer::from(s.clone()),
            DatexExpressionData::Decimal(d) => ValueContainer::from(d.clone()),
            DatexExpressionData::Integer(i) => ValueContainer::from(i.clone()),
            DatexExpressionData::Endpoint(e) => ValueContainer::from(e.clone()),
            DatexExpressionData::List(arr) => {
                let entries = arr
                    .iter()
                    .map(|e| ValueContainer::try_from(&e.data))
                    .collect::<Result<Vec<ValueContainer>, ()>>()?;
                ValueContainer::from(List::from(entries))
            }
            DatexExpressionData::Map(pairs) => {
                let entries = pairs
                    .iter()
                    .map(|(k, v)| {
                        let key = ValueContainer::try_from(&k.data)?;
                        let value = ValueContainer::try_from(&v.data)?;
                        Ok((key, value))
                    })
                    .collect::<Result<Vec<(ValueContainer, ValueContainer)>, ()>>()?;
                ValueContainer::from(Map::from(entries))
            }
            _ => Err(())?,
        })
    }
}

