WHITESPACE = _{ " " | NEWLINE | comment | multiline_comment }

comment = _{ "//" ~ (!NEWLINE ~ ANY)* }
multiline_comment = _{ "/*" ~ (!"*/" ~ ANY)* ~ "*/" }

// simple identifier such as primitive types or variables
// such as 42 or []
ident = !{
	object |
	array |
	text |
	decimal |
    integer |
	literals |
    placeholders |
    variable
}

// term is either a single identifier or a list of expressions
// such as "test" or (a + b) or (a+b;)

term = _{
    "(" ~ statements? ~ ")" |
	ident
}

// operators
multiplicative_operator = { "*" | "/" | "%" }
additive_operator = { "+" | "-" }

// expression
// can consist of two levels, either multiplicative (prio) or additive
// 1 + 2
// 1 * 2
// 1 * x(1)
//multiplicative_expression = { atom ~ (multiplicative_operator ~ atom)+ }
//additive_expression = { (multiplicative_expression | atom) ~ (additive_operator ~ (multiplicative_expression | atom))+ }


// apply
// can apply a ident to a term or multiple terms to a term, or function as a property access
// when prefixed with a dot
// apply:
//  test 42
//  test (1)
//  test (1)(2+2)
// property access:
//  test.x
//  text.x.(y)
// combined
//  test.x(1,2)(3).y
apply = ${("(" ~ statements? ~ ")" | ident) ~ ((WHITESPACE+ ~ (tuple|ident)) | (WHITESPACE* ~ params) | prop)+}

// any property access (such as .y or .(1+2))
prop = { WHITESPACE* ~ "." ~ term }
// params used when applying a scope to a function (e.g. test(x+y) or test(1))
params = !{ "(" ~ statements? ~ ")" }

// additive operation
level_2_operation = !{(level_1_operation | apply | term) ~ (additive_operator ~ (level_1_operation | apply | term))+}
// multiplicative operation
level_1_operation = !{(apply | term) ~ (multiplicative_operator ~ (apply | term))+}

// assignment operation
assignment = !{ variable ~ "=" ~ expression }



tuple = !{ term ~ "," ~ (term ~ ","?)+ }

// expression
// can be either:
// - any operation (apply, level_1_operation, level_2_operation)
// - assignment
// - tuple
// - term
expression = _{ level_2_operation | level_1_operation | apply | assignment | tuple | term }


// literal primitive values
// makes sure truefalse is threaded as variable and not as literal literal
// - true
// - false
// - null
boolean = { "true" | "false" }
null = { "null" }
void = { "void" }
reserved_literals = _{ boolean | null | void }
literals = _{ reserved_literals ~ !ASCII_ALPHANUMERIC }


// placeholder
// can be the following:
// - ?
// - ?42
placeholders = _{ placeholder_with_index | placeholder }
placeholder_with_index = { "?" ~ ASCII_DIGIT+ }
placeholder = { "?" }

// object
// - {}
// - { "x": 1, "y": 4 }
object = {
    "{" ~ "}" |
    "{" ~ pair ~ ("," ~ pair)* ~ "}"
}

// pair
// "test": 42
pair = { text ~ ":" ~ term }

// array
// such as [1,2] or []
array = {
    "[" ~ tuple? ~ "]"
}


// integer
// such as 42
integer = @{
    "-"?
    ~ ("0" | ASCII_NONZERO_DIGIT ~ ASCII_DIGIT*)
}

// decimal
// such as 4.2 or 4.
decimal = @{
    "-"?
    ~ ("0" | ASCII_NONZERO_DIGIT ~ ASCII_DIGIT*)
    ~ ("." ~ ASCII_DIGIT*)
    ~ (^"e" ~ ("+" | "-")? ~ ASCII_DIGIT+)?
}


// text
// such as 'test' or "test" including proper escape literals
text = { double_quoted_text | single_quoted_text }
double_quoted_text = { "\"" ~ double_text_chunk* ~ "\"" }
single_quoted_text = { "'" ~ single_text_chunk* ~ "'" }
double_text_chunk = _{ escape_sequence | double_normal_chars }
single_text_chunk = _{ escape_sequence | single_normal_chars }
escape_sequence = { "\\" ~ ( "\"" | "'" | "\\" | "n" | "t" | "r" ) }
double_normal_chars = { (!( "\"" | "\\" ) ~ ANY)+ }
single_normal_chars = { (!( "'" | "\\" ) ~ ANY)+ }

// variable
// such as myvar
variable = @{ (ASCII_ALPHA | "_") ~ (ASCII_ALPHANUMERIC | "_")* }

end_of_statement = { ";" }

// statements
// a single expression or chained expressions separated with ;
statements = _{ expression ~ (end_of_statement+ ~ expression)* ~ end_of_statement* }

datex = _{ SOI ~ statements? ~ EOI }
