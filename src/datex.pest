WHITESPACE = _{ " " | NEWLINE | comment | multiline_comment }

comment = _{ "//" ~ (!NEWLINE ~ ANY)* }
multiline_comment = _{ "/*" ~ (!"*/" ~ ANY)* ~ "*/" }

// simple identifier such as primitive types or variables
// such as 42 or []
term = !{
	object |
	array |
	text |
	decimal |
    integer |
	literals |
    placeholders |
    variable
}

// term_or_scope is either a single identifier or a list of expressions
// such as "test" or (a + b) or (a+b;)

term_or_scope = _{
    "(" ~ statements? ~ ")" |
	term
}

// operators
multiplicative_operator = { "*" | "/" | "%" }
additive_operator = { "+" | "-" }

// apply
// can apply a term to a term_or_scope or multiple terms to a term_or_scope, or function as a property access
// when prefixed with a dot
// apply:
//  test 42
//  test (1)
//  test (1)(2+2)
// property access:
//  test.x
//  text.x.(y)
// combined
//  test.x(1,2)(3).y
apply = ${("(" ~ statements? ~ ")" | term) ~ ((WHITESPACE+ ~ (tuple|term)) | (WHITESPACE* ~ params) | prop)+}

// any property access (such as .y or .(1+2))
prop = { WHITESPACE* ~ "." ~ term_or_scope }
// params used when applying a scope to a function (e.g. test(x+y) or test(1))
params = !{ "(" ~ statements? ~ ")" }

// additive operation
level_2_operation = !{(level_1_operation | apply | term_or_scope) ~ (additive_operator ~ (level_1_operation | apply | term_or_scope))+}
// multiplicative operation
level_1_operation = !{(apply | term_or_scope) ~ (multiplicative_operator ~ (apply | term_or_scope))+}

// assignment operation
assignment = !{ variable ~ "=" ~ expression }

// declaration operation
var_type = {"val" |"ref"}
type_declaration = { ":" ~ inline_expression }
declaration = !{ var_type ~ variable ~ type_declaration? ~ "=" ~ expression }

// expression
// can be either:
// - any operation (apply, level_1_operation, level_2_operation)
// - assignment
// - declaration
// - tuple
// - term_or_scope
expression = _{ declaration | level_2_operation | level_1_operation | apply | assignment | tuple | term_or_scope }
expression_without_tuple = _{ declaration | level_2_operation | level_1_operation | apply | assignment | term_or_scope }
expression_with_key_value = _{ declaration | level_2_operation | level_1_operation | apply | assignment | key_value | term_or_scope }

// expression that can used inline at all locations (e.g. type declarations). TODO improve this concept
inline_expression = _{ declaration | level_2_operation | level_1_operation | apply | term_or_scope }

// tuple
// combination of 2-n expressions, separated with a ",", with optional keys
// a single key-value pair (e.g. "a: 4") is also interpreted as a tuple
literal_key = @{ (ASCII_ALPHA | "_") ~ (ASCII_ALPHANUMERIC | "_")* }
key = _{text | literal_key}
key_value = { key ~ ":" ~ expression_without_tuple}
tuple_element = _{key_value | expression_without_tuple}
tuple = !{ (tuple_element ~ "," ~ (tuple_element ~ ","?)+) | (key_value ~ ","?) }
keyed_tuple = !{ (key_value ~ "," ~ (key_value ~ ","?)+) | (key_value ~ ","?) }
indexed_tuple = !{ (expression_with_key_value ~ "," ~ (expression_with_key_value ~ ","?)+) | (expression_with_key_value ~ ","?) }


// literal primitive values
// makes sure truefalse is threaded as variable and not as literal literal
// - true
// - false
// - null
boolean = { "true" | "false" }
null = { "null" }
void = { "void" }
reserved_literals = _{ boolean | null | void }
literals = _{ reserved_literals ~ !ASCII_ALPHANUMERIC }


// placeholder
// can be the following:
// - ?
// - ?42
placeholders = _{ placeholder_with_index | placeholder }
placeholder_with_index = { "?" ~ ASCII_DIGIT+ }
placeholder = { "?" }

// object
// - {}
// - { "x": 1, "y": 4 }
object = { "{" ~ keyed_tuple? ~ "}"}

// pair
// "test": 42
pair = { text ~ ":" ~ term_or_scope }

// array
// such as [1,2] or []
array = {
    "[" ~ (indexed_tuple)? ~ "]"
}


// integer
// such as 42
integer = @{
    "-"?
    ~ ("0" | ASCII_NONZERO_DIGIT ~ ASCII_DIGIT*)
}

// decimal
// such as 4.2 or 4.
decimal = @{
    "-"?
    ~ ("0" | ASCII_NONZERO_DIGIT ~ ASCII_DIGIT*)
    ~ ("." ~ ASCII_DIGIT*)
    ~ (^"e" ~ ("+" | "-")? ~ ASCII_DIGIT+)?
}


// text
// such as 'test' or "test" including proper escape literals
text = { double_quoted_text | single_quoted_text }
double_quoted_text = { "\"" ~ double_text_chunk* ~ "\"" }
single_quoted_text = { "'" ~ single_text_chunk* ~ "'" }
double_text_chunk = _{ escape_sequence | double_normal_chars }
single_text_chunk = _{ escape_sequence | single_normal_chars }
escape_sequence = { "\\" ~ ( "\"" | "'" | "\\" | "n" | "t" | "r" ) }
double_normal_chars = _{ (!( "\"" | "\\" ) ~ ANY)+ }
single_normal_chars = _{ (!( "'" | "\\" ) ~ ANY)+ }

// variable
// such as myvar
variable = @{ (ASCII_ALPHA | "_") ~ (ASCII_ALPHANUMERIC | "_")* }

end_of_statement = { ";" }

// statements
// a single expression or chained expressions separated with ;
statements = _{ expression ~ (end_of_statement+ ~ expression)* ~ end_of_statement* }

datex = _{ SOI ~ statements? ~ EOI }
